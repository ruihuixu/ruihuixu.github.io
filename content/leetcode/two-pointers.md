---
title: "算法笔记：深入理解双指针思想 (Two Pointers)"
date: 2026-01-18T00:00:00+08:00
lastmod: 2026-01-18T23:00:00+08:00
draft: false
tags:
  - "Algorithm"
  - "Data Structure"
  - "Two Pointers"
categories:
  - "LeetCode"
description: "从快慢指针到滑动窗口，总结 LeetCode 中双指针法的核心解题模式与思维框架。"
---

## 引言

最近集中刷了 LeetCode 的双指针题。如果不做总结，双指针很容易被当成零散“技巧”；但它本质是一种**把嵌套循环的 $O(N^2)$ 降为线性遍历 $O(N)$** 的通用思维：用两个指针维护“有效区间/有效状态”，让每个元素最多进出有限次。

本文把双指针归纳为三种最常用的“物理模型”：

- **快慢指针**：一个探路，一个维护有效边界（原地修改/过滤）
- **左右对撞指针**：利用有序性从两端逼近（剪枝）
- **滑动窗口**：动态区间，扩张找可行解，收缩找最优解或维持合法性

---

## 核心心智：先说清楚“谁在动、维护什么不变量”

写双指针时，建议先在脑子里回答两件事（和写二分“先锁定区间定义”是一个套路）：

1. **两个指针分别代表什么含义**（边界？候选？下一个写入位置？窗口左右端？）
2. **循环过程中必须一直成立的不变量是什么**
   - 例如：`[0, slow)` 永远是“已处理且合法”的区域
   - 例如：窗口 `[left, right]` 永远满足某个约束（或在 while 内恢复约束）

不变量一旦明确，指针移动方向和更新时机就会自然确定。

---

## 1. 快慢指针 (Fast & Slow Pointers)

### 适用场景

- **原地修改数组**：删除/过滤、去重、稳定压缩
- **链表**：判环、找中点、找倒数第 K 个（变体）

### 核心模型：探索 vs 建设

- `fast`：负责向前扫描（探索新元素）
- `slow`：负责维护“有效数据”的边界（建设新数组/新链表的尾部）

### 复杂度

- 时间复杂度：$O(N)$
- 空间复杂度：$O(1)$

### 经典题目（数组原地修改）

- **[27. 移除元素](https://leetcode.cn/problems/remove-element/)**
  - 思路：`fast` 扫描，遇到不是 `val` 的元素就写到 `nums[slow]`，然后 `slow += 1`
- **[26. 删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)**
  - 思路：有序性保证重复相邻；当 `nums[fast] != nums[slow]` 时扩展有效区
- **[283. 移动零](https://leetcode.cn/problems/move-zeroes/)**
  - 思路：先用快慢指针“过滤掉 0”并稳定前移，再把尾部补 0
- **[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)**
  - 思路：从后往前的双指针 + 计数器跳过被退格的字符，实现 $O(1)$ 空间

### 扩展补充（链表）

- **[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)**
  - 思路：`fast` 每次两步，`slow` 每次一步；相遇则有环（龟兔赛跑）

---

## 2. 左右对撞指针 (Collision Pointers)

### 适用场景

- **有序数组**（或能通过排序获得有序性）
- 需要在两端收缩搜索空间：两数之和/三数之和、最大面积等

### 核心模型：利用有序性剪枝

当数组有序时，当前 `left/right` 的组合若不满足条件，可以**确定性排除一整片解空间**，因此每个指针只会单向移动，整体仍是 $O(N)$（或排序后 $O(N^2)$）。

### 经典题目

- **[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-sorted-array/)**
  - 思路：最大平方一定来自两端；比较 `nums[left]^2` 与 `nums[right]^2`，把更大的从后往前填

### 扩展补充：N 数之和与容器

- **[15. 三数之和](https://leetcode.cn/problems/3sum/)**（高频）
  - 思路：先排序；固定 `i`，对区间 `[i+1, n-1]` 做对撞双指针
  - 难点：**去重**（`i` 去重 + `left/right` 去重）
- **[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)**
  - 思路：面积由短板决定；移动短板才“可能”变大，所以每次移动更短的一侧

---

## 3. 滑动窗口 (Sliding Window)

### 适用场景

- 子数组/子串问题：最长/最短、计数、覆盖、满足约束的最小窗口等
- 特征：窗口左右边界都只会单调移动（每个元素最多进窗口一次、出窗口一次）

### 核心模型：扩张找可行解，收缩维持合法性/优化答案

- `right`：主动扩张，把新元素纳入窗口并更新状态
- `left`：当窗口满足条件（或违反条件）时，通过收缩恢复不变量，同时更新最优答案

### 通用代码模板（伪代码）

```python
def sliding_window(nums):
    left = 0
    # state = ...
    for right in range(len(nums)):
        c = nums[right]
        # 1) 进窗口：update_state(c)

        # 2) 收缩窗口：在这里维持窗口不变量（合法性）或尝试优化答案
        while condition_met:  # 例如：窗口已覆盖/窗口和 >= target/窗口重复超标等
            # 记录答案：注意是收缩前记录，还是收缩后记录
            # ans = ...

            d = nums[left]
            # 3) 出窗口：remove_state(d)
            left += 1

    # return ans
```

### 常见易错点（写之前先过一遍）

- **答案更新时机**：有些题应在“满足条件时”更新（收缩前），有些题应在“每次扩张后”更新
- **状态维护**：窗口内计数/哈希表更新要与 `left/right` 移动严格配套
- **循环条件**：`while condition_met` 是窗口题的灵魂，写错会导致死循环或漏解

---

## 总结：双指针的“口头禅”

- 先定义两个指针的语义，再写代码；**不变量**必须从头到尾成立。
- 能用快慢就别用额外数组：`slow` 就是“新数组尾指针”。
- 对撞指针必须依赖单调性（排序/有序）；一旦失去单调性就不能保证线性移动。
- 滑动窗口里每个元素“最多进出一次”，所以常见最优是 $O(N)$。